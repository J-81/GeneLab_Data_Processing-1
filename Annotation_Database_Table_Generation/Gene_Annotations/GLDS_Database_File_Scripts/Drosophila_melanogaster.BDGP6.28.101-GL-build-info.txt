Build done on:
    17-June-2022

Used gtf file:
    https://ftp.ensembl.org/pub/release-101/gtf/drosophila_melanogaster/Drosophila_melanogaster.BDGP6.28.101.gtf.gz

Used org.Dm.eg.db version:
    3.15.0

Used STRINGdb version:
    2.8.4

Used PANTHER.db version:
    1.0.11


All session info:

R version 4.2.0 (2022-04-22)
Platform: x86_64-apple-darwin17.0 (64-bit)
Running under: macOS Big Sur/Monterey 10.16

Matrix products: default
BLAS:   /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRblas.0.dylib
LAPACK: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRlapack.dylib

locale:
[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8

attached base packages:
[1] stats4    stats     graphics  grDevices utils     datasets  methods  
[8] base     

other attached packages:
 [1] org.Dm.eg.db_3.15.0  rtracklayer_1.56.0   GenomicRanges_1.48.0
 [4] GenomeInfoDb_1.32.2  PANTHER.db_1.0.11    RSQLite_2.2.14      
 [7] AnnotationHub_3.4.0  BiocFileCache_2.4.0  dbplyr_2.2.0        
[10] AnnotationDbi_1.58.0 IRanges_2.30.0       S4Vectors_0.34.0    
[13] Biobase_2.56.0       BiocGenerics_0.42.0  STRINGdb_2.8.4      
[16] forcats_0.5.1        stringr_1.4.0        dplyr_1.0.9         
[19] purrr_0.3.4          readr_2.1.2          tidyr_1.2.0         
[22] tibble_3.1.7         ggplot2_3.3.6        tidyverse_1.3.1     

loaded via a namespace (and not attached):
  [1] colorspace_2.0-3              rjson_0.2.21                 
  [3] ellipsis_0.3.2                XVector_0.36.0               
  [5] fs_1.5.2                      rstudioapi_0.13              
  [7] hash_2.2.6.2                  bit64_4.0.5                  
  [9] interactiveDisplayBase_1.34.0 fansi_1.0.3                  
 [11] lubridate_1.8.0               sqldf_0.4-11                 
 [13] xml2_1.3.3                    codetools_0.2-18             
 [15] cachem_1.0.6                  jsonlite_1.8.0               
 [17] Rsamtools_2.12.0              broom_0.8.0                  
 [19] png_0.1-7                     shiny_1.7.1                  
 [21] BiocManager_1.30.18           compiler_4.2.0               
 [23] httr_1.4.3                    backports_1.4.1              
 [25] Matrix_1.4-1                  assertthat_0.2.1             
 [27] fastmap_1.1.0                 cli_3.3.0                    
 [29] later_1.3.0                   htmltools_0.5.2              
 [31] tools_4.2.0                   igraph_1.3.1                 
 [33] gtable_0.3.0                  glue_1.6.2                   
 [35] GenomeInfoDbData_1.2.8        rappdirs_0.3.3               
 [37] Rcpp_1.0.8.3                  cellranger_1.1.0             
 [39] vctrs_0.4.1                   Biostrings_2.64.0            
 [41] proto_1.0.0                   rvest_1.0.2                  
 [43] mime_0.12                     lifecycle_1.0.1              
 [45] restfulr_0.0.14               gtools_3.9.2.1               
 [47] XML_3.99-0.9                  zlibbioc_1.42.0              
 [49] scales_1.2.0                  MatrixGenerics_1.8.0         
 [51] hms_1.1.1                     promises_1.2.0.1             
 [53] SummarizedExperiment_1.26.1   parallel_4.2.0               
 [55] RColorBrewer_1.1-3            yaml_2.3.5                   
 [57] curl_4.3.2                    memoise_2.0.1                
 [59] stringi_1.7.6                 BiocVersion_3.15.2           
 [61] BiocIO_1.6.0                  plotrix_3.8-2                
 [63] caTools_1.18.2                filelock_1.0.2               
 [65] BiocParallel_1.30.3           chron_2.3-57                 
 [67] matrixStats_0.62.0            rlang_1.0.2                  
 [69] pkgconfig_2.0.3               bitops_1.0-7                 
 [71] lattice_0.20-45               GenomicAlignments_1.32.0     
 [73] bit_4.0.4                     tidyselect_1.1.2             
 [75] plyr_1.8.7                    magrittr_2.0.3               
 [77] R6_2.5.1                      gplots_3.1.3                 
 [79] generics_0.1.2                DelayedArray_0.22.0          
 [81] DBI_1.1.2                     gsubfn_0.7                   
 [83] pillar_1.7.0                  haven_2.5.0                  
 [85] withr_2.5.0                   KEGGREST_1.36.0              
 [87] RCurl_1.98-1.6                modelr_0.1.8                 
 [89] crayon_1.5.1                  KernSmooth_2.23-20           
 [91] utf8_1.2.2                    tzdb_0.3.0                   
 [93] grid_4.2.0                    readxl_1.4.0                 
 [95] blob_1.2.3                    reprex_2.0.1                 
 [97] digest_0.6.29                 xtable_1.8-4                 
 [99] httpuv_1.6.5                  munsell_0.5.0                

Built with:
Rscript build-genome-annots-tab.R FLY

#!/usr/bin/env Rscript

# Maintained by Mike Lee (Mike.Lee@nasa.gov)
# GeneLab script for generating organism ENSEMBLE annotation tables
# Example usage: Rscript build-genome-annots-tab.R MOUSE

############################################
############ pre-flight checks #############
############################################

args <- commandArgs(trailingOnly = TRUE)

currently_accepted_orgs <- c("MOUSE", "HUMAN", "ARABIDOPSIS", "FLY")

# making sure a positional argument was provided
if ( length(args) < 1 ) {
    cat("\n  One positional argument is required that specifies the target organism. Currently available include:\n")

    for ( item in currently_accepted_orgs ) {

        cat(paste0("\n        ", item))
    }

    cat("\n\n")

    quit()

} else {

    suppressWarnings(target_organism <- toupper(args[1]))

}

# making sure it is one we are prepared to handle
if ( ! target_organism %in% currently_accepted_orgs ) {

    cat(paste0("\n  '", args[1], "' isn't a valid entry.\n"))

    cat("\n  The currently available organisms include:\n")

    for ( item in currently_accepted_orgs ) {

        cat(paste0("\n        ", item))
    }

    cat("\n\n")

    quit()

}


############################################
######### setting some things up ###########
############################################

library(tidyverse)
library(STRINGdb)
library(PANTHER.db)
library(rtracklayer)


# setting primary keytype, right now, TAIR if arabidopsis, ENSEMBL if anything else
if ( target_organism == "ARABIDOPSIS" ) {

    primary_keytype <- "TAIR"

} else {

    primary_keytype <- "ENSEMBL"

}

wanted_keys_vec <- c("SYMBOL", "GENENAME", "REFSEQ", "ENTREZID")
org_tab_link <-
    "https://raw.githubusercontent.com/asaravia-butler/GeneLab_Data_Processing/master/RNAseq/organisms.csv"
ref_tab_link <-
    "https://raw.githubusercontent.com/asaravia-butler/GeneLab_Data_Processing/master/RNAseq/GeneLab_Reference_and_Annotation_Files/GL-DPPD-7101-E_ensembl_refs.csv"


############################################
######## getting down to business ##########
############################################

# setting this so any downloads won't timeout
options(timeout = 600)

# getting org taxid and org db name
organism_table <- read.csv(org_tab_link)

ref_table <- read.csv(ref_tab_link)

target_taxid <- organism_table %>%
    filter(name == target_organism) %>%
    pull(taxon)

target_org_db <- organism_table %>%
    filter(name == target_organism) %>%
    pull(annotations)

target_species_designation <- organism_table %>%
    filter(name == target_organism) %>%
    pull(species)

gtf_link <- ref_table %>%
    filter(Organism == target_species_designation) %>%
    pull(Annotation.File)

# making output prefix
base_gtf_filename <- basename(gtf_link)
base_output_name <- str_replace(base_gtf_filename, ".gtf.gz", "")

out_table_filename <- paste0(base_output_name, "-GL-annotations.tsv")
out_log_filename <- paste0(base_output_name, "-GL-build-info.txt")

# making sure output file doesn't exist already, if it does, we're exiting without overwriting
if ( file.exists(out_table_filename) ) {

    cat("\n-------------------------------------------------------------------------------------------------\n")
    cat(paste0("\n  The file that would be created, '", out_table_filename, "', exists already.\n"))
    cat(paste0("\n  We don't want to overwrite it accidentally. Move it and run this again if wanting to proceed.\n"))
    cat("\n-------------------------------------------------------------------------------------------------\n")

    quit()

}

## getting all unique gene IDs
# changing link to be https if it's currently http
gtf_link <- str_replace(gtf_link, "http:", "https:")

gtf_obj <- import(gtf_link)
unique_IDs <- gtf_obj$gene_id %>% unique()

# removing gtf object now that we don't need it cause it can soak up a lot of RAM
rm(gtf_obj)

ann.dbi <- target_org_db

# installing org db if needed
if ( ! require(ann.dbi, character.only = TRUE)) {

    BiocManager::install(ann.dbi, ask = FALSE)

}

library(ann.dbi, character.only = TRUE)

annot <- data.frame(unique_IDs)
colnames(annot) <- primary_keytype

for ( key in wanted_keys_vec ) {

    if ( key %in% columns(eval(parse(text = ann.dbi), env = .GlobalEnv))) {

        new_list <- mapIds(eval(parse(text = ann.dbi), env = .GlobalEnv), keys = unique_IDs, keytype = primary_keytype, column = key, multiVals = "list")

        # they come as lists when we accept the multiple hits, so converting to character strings here
        annot[[key]] <- sapply(new_list, paste, collapse = "|")

    }
}

# adding STRINGdb annots
string_db <- STRINGdb$new(version = "11", species = target_taxid, score_threshold = 0)
string_map <- string_db$map(annot, primary_keytype, removeUnmappedRows = FALSE, takeFirst = FALSE)

# adding a return because the stringdb stdout doesn't have one and it bothers me
cat("\n\n")

# combining if there are any with multiple string IDs
tab_with_multiple_STRINGids_combined <-
    data.frame(row.names = annot[[primary_keytype]])

for ( curr_gene_ID in row.names(tab_with_multiple_STRINGids_combined) ) {

    # getting current gene's STRING_ids and turning into
    # combined a vector
    curr_STRING_ids <- string_map %>%
        filter(!!rlang::sym(primary_keytype) == curr_gene_ID) %>%
        pull(STRING_id) %>% paste(collapse = "|")

    # adding to table
    tab_with_multiple_STRINGids_combined[curr_gene_ID, "STRING_id"] <- curr_STRING_ids

}

# moving primary_keytype back to being a column
tab_with_multiple_STRINGids_combined <-
    tab_with_multiple_STRINGids_combined %>%
    rownames_to_column(primary_keytype)

# combining string column
annot <- dplyr::left_join(annot,
                          tab_with_multiple_STRINGids_combined,
                          by = primary_keytype)

# adding GO slim annotations
pthOrganisms(PANTHER.db) <- target_organism

# since we are using ENTREZIDs to pull from the PANTHER db, and there can be multiple ENTREZIDs for a gene, we need to split them first,
# so doing this as a loop building the new GOSLIM annotation column

for ( curr_row in 1:dim(annot)[1] ) {

    curr_entry <- annot[curr_row, "ENTREZID"]

    # dealing with NAs
    if ( curr_entry == "NA" ) {

        annot[curr_row, "GOSLIM_IDS"] <- "NA"

    } else if ( ! grepl("|", curr_entry, fixed = TRUE) ) {

        # this handles if there is only one ENTREZID
        curr_GO_IDs <- mapIds(PANTHER.db, keys = curr_entry, keytype = "ENTREZ", column = "GOSLIM_ID", multiVals = "list") %>% unlist() %>% as.vector()

        # handles if none were found
        if ( is.null(curr_GO_IDs) ) {

            curr_GO_IDs <- "NA"
        }

        annot[curr_row, "GOSLIM_IDS"] <- paste(curr_GO_IDs, collapse = "|")

    } else {

        # this block handles if there are multiple ENTREZIDs, if this is the case,
        # we want to split them, get the GO IDs for all, combine them, and remove any duplicates

        # splitting them
        curr_entry_vec <- strsplit(curr_entry, "|", fixed = TRUE)

        # starting vector of current GO IDs
        curr_GO_IDs <- vector()

        # looping through, getting GO IDs, and combining them
        for ( curr_entry in curr_entry_vec ) {

            new_GO_IDs <- mapIds(PANTHER.db, keys = curr_entry, keytype = "ENTREZ", column = "GOSLIM_ID", multiVals = "list") %>% unlist() %>% as.vector()

            # adding to building vector of all GO IDs
            curr_GO_IDs <- c(curr_GO_IDs, new_GO_IDs)

        }

        # removing any dups
        curr_GO_IDs <- unique(curr_GO_IDs)

        # handles if none were found
        if ( length(curr_GO_IDs) == 0 ) {

            curr_GO_IDs <- "NA"
        }

        # adding to table
        annot[curr_row, "GOSLIM_IDS"] <- paste(curr_GO_IDs, collapse = "|")

    }

}


############################################
##### writing out annots and run info ######
############################################

# ordering first
annot <- annot %>% arrange(.[[1]])
# writing out annotations table
write.table(annot, out_table_filename, sep = "\t", quote = FALSE, row.names = FALSE)


# getting date of run
date_generated <- format(Sys.time(), "%d-%B-%Y")

# writing out building info
writeLines(paste(c("Build done on:\n    ", date_generated), collapse = ""), out_log_filename)
write(paste(c("\nUsed gtf file:\n    ", gtf_link), collapse = ""), out_log_filename, append = TRUE)
write(paste(c("\nUsed ", ann.dbi, " version:\n    ", packageVersion(ann.dbi) %>% as.character()), collapse = ""), out_log_filename, append = TRUE)
write(paste(c("\nUsed STRINGdb version:\n    ", packageVersion("STRINGdb") %>% as.character()), collapse = ""), out_log_filename, append = TRUE)
write(paste(c("\nUsed PANTHER.db version:\n    ", packageVersion("PANTHER.db") %>% as.character()), collapse = ""), out_log_filename, append = TRUE)

write("\n\nAll session info:\n", out_log_filename, append = TRUE)
write(capture.output(sessionInfo()), out_log_filename, append = TRUE)
